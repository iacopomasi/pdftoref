\section{Sviluppo dell'applicativo} \label{software}

L'applicativo è stato realizzato per mezzo di scripting python \cite{pydoc}, su sistema operativo GNU/Linux, in particolare sotto la versione Ubuntu Linux 8.04. Si è trattato con buoni risultati i casi più diffusi di bibliografia che utilizzano una struttura standard benformata per elencare le varie voci. Si è riusciti a trattare con risultati sufficienti anche i casi in cui la bibliografia non segue una regola predefinita.

Estratta la bibliografia sono state implementate delle funzioni che effettuano richieste SOAP al WebService di Google \cite{GWS} tramite implementazione proxy in python \cite{ibm-py-ws} per recuperare la Url di una risorsa Web a maggiore ranking, correlata alla voce della bibliografia. 

Infine sono state sviluppate delle funzioni che costruiscono un file HTML contenente tutte le voci della bibliografia con il relativo link remoto e l'eventuale BibTex estratto dalla pagina HTML della risorsa remote come ad esempio CiteSeer, Portal ACME etc.

In figura sottostante sono riportati i passi princiapli dello script che vengono eseguiti:
\begin{enumerate}
	\item Estrazione del testo tramite PdfMiner che fornisce dal PDF un file XML
	\item Implementazione dell'euristiche basate su espressioni regolari per localizzare la bibliografia e estrarre le voci
	\item Estrazione dei titoli da ogni voce
	\item Scrittura del file html con l'eventuale ricerca via  Google webservice. Queste opzioni di ricerca si possono abilitare o meno, tramite parametri all'applicativo
\end{enumerate}


\begin{lstlisting}[frame=r,caption=Il File principale - pdftoref.py ,breaklines=true,basicstyle=\small]{}

# Si estrae il testo dal Pdf in formato XML
document = Pdf2Txt.getTextFromPdf(content)

# Si estrae la bibliografia dal file XML come testo semplice
plainText = Extractor.getPlainText(document)

if plainText:
	# Si cerca di estrarre le varie voci della bibliografia 
	entries = Extractor.entriesExtractor(plainText)
	if entries:
		# Si scrive ciascuna entry in un file HTML col relativo collegamento
		HtmlWriter.write(entries,titles,content,urlFlag,bibtexFlag)

\end{lstlisting}

\subsection{Estrazione Testo Pdf}
Il primo problema che si presenta nell'estrazione di dati dai file Pdf è l'estrazione del testo. Pdf è un formato di stampa e talvolta tratta il testo alla stregua di immagini o in alcuni casi descrive le lettere di una solita parola in maniera diversa dalle altre per ottenere un buon risultato di stampa, ma un risultato pessimo nell'analisi del testo. Non è facile perciò ottenere un \textit{clear plain text} da un file Pdf. Tuttavia sono presenti un numero di tools e librerie che svolgono questa funzione in modo più o meno appropriato, a seconda delle esigenze dell'utente. Ci sono dei tools che dato un file pdf estraggono un file XML che contiene oltre al testo la descrizione della formattazione del documento. 
In particolare si è analizzato e testato tre strumenti diversi:
\begin{itemize}
 \item \textit{pdftohtml} è un applicativo, distribuito come \textit{free software}, a linea di comando in dotazione con praticamente qualsiasi distribuzione GNU/Linux. E' utile per la conversione di un file pdf in html o xml e abbstanza veloce in quanto scritto in C++.
 \item \textit{PyPdf} è una libreria python utile per la manipolazione di documenti pdf, estrae testo semplice. Permette di fare \textit{merge} di pdf, ruotarli e tagliarli.
 \item \textit{PDFMiner} è una suite di programmi sviluppata completamente in python, scritta da Yusuke Shinyama, che implementa funzionalità di estrazione testo e formattazione da files pdf. In particolare fornisce la possibilità di ottenere un file xml equivalente al pdf.
\end{itemize}

Sottolineando che si è ricercato tutti strumenti al limite con una licenza opensource\footnote{ricordarsi di citare i siti di questi progetti}, la scelta è infine caduta sulla suite PDFMiner perchè è scritta completamente in python e perciò meglio integrabile col nostro progetto, è funzionale per i nostri obiettivi ed è di semplice applicazione pratica.
In particolare PDFMiner offre un interfaccia python direttamente integrabile con altro software python, in queso senso la scelta è anche ricaduta su questo tool:ha permesso un numero esiguo di modifiche al codice; in pratica solo la creazione di un file di binding tra il tool e l'applicativo pdftoref. La funzione di binding prende il nome \textit{``getTextFromPdf(PdfFile)''} e ritorna un documento XML benformato di questo tipo:

\begin{lstlisting}[language=XML,frame=r,caption=Esempio di XML relativo a documento PDF ,breaklines=true,basicstyle=\small]{Esempio di XML relativo a documento PDF}
...
<document>
 <page id="0" bbox="92.381,119.270,429.987,660.000" rotate="0">
  <text font="DMFDHG+CMBX12" direction="1" bbox="134.765, 361.365,  62.920, 11.955" size="11.955">References</text>
  <text font="DMFDIK+CMR9"   direction="1" bbox="139.372, 340.543, 341.146,  8.966" size="8.966">1. J.-F. Arias, C.P. Lai, S. Surya, R. Kasturi, and A.K. Chhabra. Interpretation of</text>
  <text font="DMFDIK+CMR9"   direction="1" bbox="140.727, 339.321, 148.241,  8.966" size="8.966">telephone system manhole drawings.</text>
  <text font="DMHOKA+CMTI9"  direction="1" bbox="157.848, 339.339, 111.177,  8.966" size="8.966">Pattern Recognition Letters</text>
  <text font="DMFDIK+CMR9"   direction="1" bbox="170.248, 339.321,  64.383,  8.966" size="8.966">, 16(1):355&#8211;359,</text>
  <text font="DMFDIK+CMR9"   direction="1" bbox="140.727, 338.099,  20.990,  8.966" size="8.966">1995.</text>
 </page>
</document>
...
\end{lstlisting}



\subsection{Ricerca References}

Ottenuto il file XML è necessario operare una ricerca nel testo per selezionare il testo relativo alla bibliografia.
Per fare ciò ci siamo basati sui seguenti criteri:
\begin{itemize}
 \item Negli articoli in inglese la bibliografia inizia sempre con la parola \textit{``Reference''} o \textit{``References''}.
 \item Negli articoli in inglese la bibliografia si trova sempre nella parte finale.
\end{itemize}

Perciò abbiamo operato una ricerca dal fondo del documento (\textit{bottom-up}) come in Figura \ref{fig:bottomup} al fine di trovare la prima occorrenza della parola \textit{``Reference''} alla quale abbiamo supposto seguire soltanto il testo relativo alla bibliografia. 
Un problema pratico che si è affrontato qui è dovuto all'estrazione del testo dal pdf. La parola ''References'' infatti'' non è sempre estratta in modo coerente a causa delle problematiche nell'analisi del testo del formato di stampa PDF citate precedentemente. Infatti potrebbe presentarsi come ''Re fe rence'' o ``R e ference'', insomma con degli spazi all'interno. Per ovviare a ciò ci siamo avvalsi delle\textbf{ espressioni regolari} in python, uno strumento molto efficacie per la manipolazione e l'analisi del testo.

\begin{figure}[htb]
\begin{center}
\includegraphics[scale=0.45]{bottomup.png}
\end{center}
\caption[Rappresentazione grafica di ricerca bottom-up]{Rappresentazione grafica di ricerca bottom-up: la ricerca è fatta prima sull'espressione regolare References (.1) dal bbasso verso l'alto del documento. Una volta trovata si ritorna indietro supponendo che tutto il testo da References in giù sia la bibliografia (2.) }
\label{fig:bottomup}
\end{figure}

\begin{subsubsection}{Espressioni Regolari}
 Le espressioni regolari (in inglese \textit{regular expression} \cite{regexp}, che può trovarsi abbreviata in regexp, regex o RE) sono grammatiche di tipo 3, cioè della tipologia più semplice. Sono uno strumento molto potente e abbastanza flessibile con cui si possono rappresentare un insiemi di stringhe. Gli insiemi caratterizzabili con espressioni regolari sono anche detti linguaggi regolari (e coincidono con quelli generabili dalle grammatiche regolari e riconoscibili dagli automi a stati finiti). Le espressioni regolari sono composte da costanti e operatori che denotano insiemi di stringhe, e da operazioni tra questi insiemi. Le espressioni regolari sono utilizzate principalmente da editor di testo per la ricerca e la sostituzione di porzioni del testo. Grande importanza rivestono inoltre nell'informatica teorica, nella quale, ad esempio, sono utilizzate per rappresentare tutti i possibili cammini su un grafo.

Le espressioni regolari operano sulle stringhe, e le stringhe più semplici sono costituite da singoli caratteri. La maggior parte dei caratteri corrisponde semplicemente a se stessa, quindi a corrisponderà alla stringa "a" (circa la discriminazione tra maiuscolo e minuscolo si veda la sezione opzioni più avanti), stessa cosa per una stringa costituita da caratteri ordinari, come a esempio spam.

Alcuni caratteri assumono invece significati particolari e vengono chiamati \textit{metacaratteri}. Laddove si voglia vengano interpretati come caratteri ordinari dovranno essere protetti. Eccone una lista completa:

\begin{verbatim}
[ \ { | ( )  ^ $ ? + * .
\end{verbatim}

Il metacarattere \textit{*} specifica che la RE che lo precede (può essere un singolo carattere, ma a esempio anche un intervallo [a-z]) può ripetersi zero o più volte, quindi a esempio pip*o trova corrispondenza in ``pio'' (zero ``p''), ``pipo'', ``pippo'', ``pipppo'' e così via.\\

Simile è il comportamento di \textit{+}, che specifica che la RE che lo precede può ripetersi una o più volte (attenzione a tale differenza!). Quindi pip+o troverà corrispondenza in ``pipo", ``pippo'', ``pipppo'' e così via, ma non in ``pio'' (al minimo una ``p'').\\

Più ristretto è il comportamento di \textit{?}, che specifica che la RE che lo precede può ripetersi zero o una volte. Quindi la nostra pip?o troverà corrispondenza solo in ``pio'' o ``pipo''.\\

\textbf{Esempio di utilizzo nella nostra applicazione}
\begin{lstlisting}[frame=r,caption=Esempio di utilizzo di espressione regolare per la ricerca ,breaklines=true,basicstyle=\small]{Esempio di utilizzo di espressione regolare per la ricerca}

# Si definisce l'espressione regolare
_references = "R ?e ?f ?e ?r ?e ?n ?c ?e ?s?"

# Si compila l'espressione regolare in un parser
r = re.compile(_references)

# Si fa effettuare la ricerca al parser in una stringa
# m contiene le occorrenze corrispondenti all'espressione regolare cercata
m = r.search(tmpTxt)
\end{lstlisting}

\end{subsubsection}

Un problema invece dovuto alla semplificazione introdotta dalle nostre ipotesi è il seguente: supponendo che la bibliografia sia correttamente individuata con la sola parola \textit{``Reference''}, non è detto che questa non possa essere seguita da altro testo diverso, come per esempio un'appendice. La nostra analisi per l'estrazioni delle voci bibliografiche è eseguita anche su questo testo aggiuntivo, generando un comportamento inaspettato, che comunque può essere semplicemente filtrato da una semplice interazione dell'utente.

\subsection{Estrazione delle Entries}
Estratta la parte di testo che riteniamo essere la bibliografia è necessario estrarre da questa le singole voci bibliografiche dette anche \textit{entries}. Abbiamo appurato statisticamente da un vasto campione di articoli che in generale si evidenziano tre tipi di formattazione possibili per la bibliografia negli articoli scientifici:
\begin{itemize}
 \item enumerazione in cui ciascuna voce ha in testa il valore dell'indice tra parentesi quadre (es. [1])
 \item enumerazione in cui ciascuna voce ha in testa il valore dell'indice puntato (es.  1.)
 \item nessun tipo di enumerazione, ciascuna voce è separata delle altre da un accapo
\end{itemize}
In particolare, una volta scartato ``References'', ci si aspetta che il testo immediatamente successivo sia la prima voce della Bibliografia, in particolare i primi caratteri dovrebbero corrispondere all'indice usato in quel determinato csao. E' possibile perciò capire in quale dei tre casi ci troviamo.
\\
Se ci troviamo nel primo caso è relativamente facile separare le singole voci bibliografiche basandosi sulle espressioni regolari. Negli altri due casi si cerca dei criteri per ricondursi al precedente.
\\
Nel caso dell'enumerazione puntata andiamo a ricercare un numero seguito da un punto. Questo criterio è poco restittivo, poichè si possono presentare nel testo della entry dei numeri seguiti da punto che non sono l'indice. Tenendo però traccia dell'ordine crescente dell'indice, andando a ricercare il valore esatto seguito dal punto e andando a verificare che questo sia preceduto da un accapo il criterio diventa sufficientemente restrittivo. Quindi si sostituisce nel testo all'indice puntato l'indice tra parentesi quadre.
\\
Nel caso in cui non ci sia nessun tipo di indice confidiamo sul fatto che le varie entries siano separate da un accapo e da un'eventuale interlinea. Sfruttando le informazioni sulla formattazione offerte dal documento XML ottenuto ricerchiamo la sequenza ordinata [ \textit{``.''} ; \textit{``accapo''} ; \textit{``lettera maiscuola''}] per identificare la separazione tra voci bibliografiche diverse. In testa a ciascuna voce inseriamo un indice tra parentesi quadre. \'E bene sottolineare che in questo caso la ricerca del pattern è fatta solo nel caso in cui tramite l'attributo ``bbox'' del tag xml ``text'', riusciamo a stimare una differenza non crescente del valore X del rettangolo che contiene il testo tra la riga \textit{i-esima} e la \textit{riga i-1 esima}. In questo modo è possibile determinare se vi è un accapo, poichè nel caso via sia un accapo la differenza nelle componente X del BBox in qui è inscritto il testo risulta non crescente. Un esempio può essere visualizzato di seguito:


\begin{lstlisting}[language=XML,frame=r,caption=Esempio di XML in cui si nota l'accapo tra References e la prima voce ,breaklines=true,basicstyle=\small]{Localizzazione dell'accapo}
...
<text direction="1" bbox="134.765, 361.365,  62.920, 11.955" size="11.955">References</text>
<text direction="1" bbox="139.372, 340.543, 341.146,  8.966" size="8.966">1. J.-F. Arias, C.P. Lai, S. Surya, R. Kasturi, and A.K. Chhabra. Interpretation of</text>
...

\end{lstlisting}

In questo caso, ponendo $ \delta  =   (bbox_{i-1}[0] - bbox_{i}[0] ) $, si ha $ \delta  = 134.765 - 139.372 \leq 0$, quindi vi è un accapo tra le due righe.



\subsection{Estrazione del titolo}
Supponendo a questo punto di essere stati in grado di dividere facilmente e in modo corretto le varie \textit{entries} è necessario per ciascuna di queste estrarre il titolo del riferimento bibliografico. Questo perchè il titolo è l'elemento di maggiore rilevanza per fare una ricerca Web collegata alla entry. Osservando la struttura delle varie bibliografie in nostro possesso abbiamo potuto verificare una certa regolarità nell'ordine degli elementi presenti in ciascuna entry.
\\
Nell'ordine compaiono:
\begin{itemize}
 \item Nomi degli autori
 \item Titolo dell'Articolo o del Libro
 \item Conferenza, Evento o Università di riferimento
 \item Anno di pubblicazione
 \item Numero di pagine
\end{itemize}

Tutti questi singoli sottoelementi della Entry sono separati tra loro in modo ambivalente o dal simbolo punto o dal simbolo virgola, a seconda dal \textit{template} usato per generare la bibliografia. Di fatto facendo una divisione della stringa basandosi su questi due simboli è possibile estrarre i singoli elementi. Fatto ciò è stato necessario trovare un criterio per selezionare tra tutti il titolo.
Poichè il titolo è di solito immediatamente successivo all'elenco degli autori e sfruttando il fatto che questo è sempre molto più lungo del nome di un autore, abbiamo definito la seguente regola:
\\
\textit{``E' scelto come titolo la prima stringa estratta che presenta una sufficiente differenza di lunghezza dalla precendete''}
\\

%Un problema è stimare la giusta soglia per giudicare la differenza sufficiente. Un'indagine statistica ci ha aiutato nel trovare una stima appropriata.
\begin{center}(Altro zampino mio - Questo lo spiego io marto. Lo raffino e ci metto un immagine.)\end{center}

In linea di massima questo criterio funziona fintanto che il titolo a sua volta non contiene altre virgole o punti, altrimenti è spezzato in sottostringhe di dimensione ridotta.


\subsection{Recupero Risorse Web}
[Iac Qui c'è il tuo zampino ho bisogno di Spiegazioni]
